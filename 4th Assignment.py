# -*- coding: utf-8 -*-
"""Prediction OF breast cancer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YTuYlMVZ1LKhfgg3UzXnwSmQ5PmGDJAd

# **Importing Libraries**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sea

"""# **Importing Data set**"""

dataset=pd.read_csv('data.csv')
dataset.head(5)

"""# **Shape of dataset**"""

dataset.shape

"""# **Description of dataset**"""

dataset.describe()

"""# **Information of dataset**"""

dataset.info()

"""# **Checking for duplicated values**"""

dataset.duplicated().sum()

"""# **Checking Null values**"""

dataset.isnull().sum()

"""# **Removing Null value column**"""

dataset=dataset.drop('Unnamed: 32',axis=1)

dataset.head()

"""# **Target Encoding**"""

dataset['diagnosis'].replace(['M','B'],[1,0],inplace=True)

dataset['diagnosis']

"""# **Barplot of target column "diagnosis"**"""

dataset.groupby(['diagnosis']).diagnosis.count()

dataset.diagnosis.value_counts().plot(kind="bar",figsize=(8,8))
plt.title("Number of positive and negative ")
plt.xlabel("diagnosis")
plt.xticks(rotation=0)
plt.ylabel("results")
plt.show()

"""# **Correlation Between all features**"""

sea.set(rc = {'figure.figsize':(40,40)})
sea.heatmap(dataset.corr(),annot=True)

"""# **Splitting data set into x(independent variable) and y (Dependent variable)**"""

x = dataset.drop(['id','diagnosis'],axis=1)
x

y=dataset.iloc[:,1]
y

"""# **Splitting Dataset into train set and test set**"""

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,random_state=0)

"""# **Feature Scalling**"""

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
x_train = sc.fit_transform(x_train)
x_test = sc.transform(x_test)

"""# **Random Forest**"""

from sklearn.ensemble import RandomForestClassifier
RMclassifier = RandomForestClassifier(n_estimators = 10, criterion = 'entropy',random_state=0)
RMclassifier.fit(x_train, y_train)

"""# **Predicted** **Results**"""

Y_Pred=RMclassifier.predict(x_test)
Y_Pred

"""# **Confusion Matrix**"""

from sklearn.metrics import confusion_matrix
confMatRM=confusion_matrix(y_test,Y_Pred)
plt.figure(figsize=(6,4))
sea.heatmap(confMatRM, annot=True)

"""# **Accuracy Score**"""

from sklearn.metrics import accuracy_score
accScoreRM=accuracy_score(y_test,Y_Pred)
print("accuracy:",accScoreRM*100)

"""# **N-fold cross validation**"""

from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
crossVal= KFold(n_splits=10, random_state=1, shuffle=True)
scores = cross_val_score(RMclassifier , x, y, scoring='accuracy', cv=crossVal, n_jobs=-1)
nfoldpredictions = RMclassifier .predict(x_test)
print("All accuracies for the 10 folds are: ",scores)
print("Average of all 10 folds of datas is: ",scores.mean())

"""# **Confusion Matrix**"""

cmK=confusion_matrix(y_test,nfoldpredictions)
plt.figure(figsize=(6,4))
sea.heatmap(cmK, annot=True)

"""# **ROC curve**"""

import sklearn.metrics as metrics
probas = RMclassifier.predict_proba(x_test)
fpr, tpr, _ = metrics.roc_curve(y_test, probas[:,0], pos_label=0)
roc_auc = metrics.auc(fpr, tpr)

f, ax = plt.subplots(figsize=(10,8))
ax.grid(False)
plt.plot(fpr, tpr, lw=1, color='red', label=f'AUC = {roc_auc:.3f}')
plt.plot([0,1], [0,1], 'k--', lw=0.5)
plt.title('ROC Curve')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.legend(loc = 'lower right')
plt.show()